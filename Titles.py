import urllib.request  # импортируем модуль
import re
# req = urllib.request.Request('https://habrahabr.ru/')
# with urllib.request.urlopen(req) as response:
#    html = response.read().decode('utf-8')
# print(html[:250])

url = 'https://habrahabr.ru/'  # адрес страницы, которую мы хотим скачать
user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'  # хотим притворяться браузером

req = urllib.request.Request('https://habrahabr.ru/', headers={'User-Agent':user_agent})
# добавили в запрос информацию о том, что мы браузер Мозилла

with urllib.request.urlopen(req) as response:
   html = response.read().decode('utf-8')


regPostTitle = re.compile('<h2 class="post__title">.*?</h2>', flags=re.U | re.DOTALL)
titles = regPostTitle.findall(html)


print(len(titles))
#print(titles[:3])

new_titles = []
regTag = re.compile('<.*?>', flags=re.U | re.DOTALL)
regSpace = re.compile('\s{2,}', flags=re.U | re.DOTALL)
for t in titles:
    clean_t = regSpace.sub("", t)
    clean_t = regTag.sub("", clean_t)
    new_titles.append(clean_t)
# for t in new_titles:
#     print(t)


for t in new_titles:
    print(t.replace("&nbsp;&rarr;", " -> "))

'''
"." Любой символ
"^" Начало строки
"$" Конец строки
"*" Повторение фрагмента нуль или более раз
"+" Повторение фрагмента один или более раз
"?" Предыдущий фрагмент либо присутствует, либо отсутствует
"\S" Любой непробельный символ.
"\s" Любой пробельный символ.
"{m,n}" Повторение предыдущего фрагмента от m до n раз включительно (жадное)
"{m,n}?" Повторение предыдущего фрагмента от m до n раз включительно (не жадное)

Регулярные выражения обладают такой особенностью, как "жадность".
Это значит, что в результат поиска попадет как можно более длинное совпадение.

compile() позволяет запомнить регулярное выражение и использовать его несколько раз.
Суть в том, что перед тем как прогнать регулярку через строку, питон должен ее "скомпилировать" - превратить строку
с регулярным выражением в специальный объект.
Строчка re.search(..., ...) сначала компилирует регулярное выражение, а потом выполняет поиск.
Если нужно поискать что-то один раз, то такая строчка очень удобна. А если нужно поискать что-то много раз,
то получится что одно и то же выражение мы компилируем много раз.
А хочется один раз скомпилировать и потом много раз пользоваться.

Выражение regName.sub('на_что_заменить', text) значит: возьми скомпилированное выражение из переменной regName,
и замени все, что соответствует этому выражению в переменной text, на строку 'на_что_заменить'.
Если первый аргумент в этом случае - пустая строка, то все найденные регуляркой куски заменятся на пустую строку,
короче говоря, удалятся.

Обычно точка в регулярном выражении означает любой символ КРОМЕ символа новой строки. Чтобы изменить такое поведение,
в компиляцию регулярки можно добавить параметры-флаги вот так: flags = re.DOTALL,
и тогда точка будет ловить вообще любой символ, включая новую строку.

Во втором питоне по умолчанию выражения типа \w, \W, \s и подобные работают только на строках ASCII,
и чтобы они работали на юникодных строках нужно написать re.U. В третьем питоне все строки и так юникодные,
поэтому необходимости в таком флаге больше нет.
'''